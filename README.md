[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15232745&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:

ANSWER:
 Software Engineering definition as a field is the systematic design, construction, implementation, testing, and documentation of software systems. To me, programming is not just about writing a piece of code to produce a desired output but entails being fully conversant with the user’s requirements and delivering functional, efficient, and user-friendly applications. Designing software involves a creative usage of practical knowledge to address problems to come up with an innovative solution where software engineering involves the use of intellectuality along with innovation in teamwork. It alters its tools and strategies to reflect technological changes in order to improve the quality of software. Finally, software engineering is the process of building the software systems that make life easier, with creativity meticulously aligned to the step-by-step processes involved in developing these systems.

What is software engineering, and how does it differ from traditional programming?
ANSWER:
Software Engineering is the adaptation of practical and organized approach to the development of software in order to have maximum reliability, efficiency and quality. This means it consists of a staged/seven-step model of software development including the design process, creation of software, testing and sustaining the software product.

Differences from Traditional Programming:Scope: The scope of SE is from application development to its maintenance and disposal but traditional programming is merely the coding step among all these phases.

Approach: Software engineering has specific practices, backed by strict application of process; traditional programming is characterized by less rigorous, more spur-of-the-moment approach.

Team Size: May require more extensive and varied group participation; plain coding can be carried out by one person or a couple of people collectively.

Documentation: Possesses a strong writing component; sometimes, regular programming entails a lack of extensive report writing.

Software Development Life Cycle (SDLC):
Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.

ANSWER:
Software Development Life Cycle (SDLC): A framework that identifies procedures and activities spanning through the entire life cycle of the software right from the developmental stage to the time of deployment and continued use. Common stages are initiation, requirements gathering and determination, architecture, construction, integration, and support.

phases of the Software Development Life Cycle.
 Planning:
Objective: Functional definition: Determine and establish goal, scope, resource requirement, and time frame with respect to the project. 
Activities: Resource assessment and evaluation; Setting up of hypothesis and testing of hypothesis; Scoping and costing; Risk assessment and conclusion. 
Outcome: Project specifications, initial scoping, and project cost and time estimate. 

 Requirement Analysis:
Objective: This step involves collecting information and demands from the various stakeholders. 
Activities: Looking at go requirements, Interviews, requirements-gathering sessions, documentation processes.
Outcome: Use Case realisation; Requirements Definition; User Stories. 

 Design:
Objective: Architecture and detailed design of the system are part of strategy planning. 
Activities: The system design involves various concepts such as the architectural design, database design, and user interface design. Outcome: schematic diagrams , concept maps, hierarchies, architecture maps, wire frames, data base architecture, mock-ups, prototypes. 

 Implementation (Coding):
Objective: Develop the code in a manner that correspond to the above design. 
Activities: We perform the coding, code reviews, and unit testing steps. 
Outcome: Program listing, commentaries and annotations, check results. 

 Testing:
Objective: Make sure that there exists a quality assurance process to Review/store software and to Check/verify that it is not buggy and meets the needs and specifications as needed.
Activities: System testing, integration testing and performance testing and testing for security. 
Outcome: Test plans, Test cases/ scripts, Bug reports, Test Summary reports. 

 Deployment:
Objective: Deploy applications to the production environment and generate releasable and installable software.
Activities: Pre-deployment preparations, staff familiarization, system configuration, and rollout. 
Outcome: downloaded software, documents that indicate the process of deploying the software, user guides.

 Maintenance:
Objective: Be available and offer help, debug problems, and update as needed.
Activities: Submission of bug reports, enhancements, finer tuning, support and tracking/analysis of user issues. 
Outcome: This may include updated software, maintenance reports, issue logs, and periodic appearances of computer experts.

Agile vs. Waterfall Models:
Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?

Agile vs. Waterfall Models:

AGILE MODEL
Approach: Iterative and incremental.

Flexibility: High, and also flexible as the need may arise to change them within the course of the undertaking.

Customer Involvement: A steady relationship with constant communication.

Phases: Some of the cycles are created with the help of planning, design, coding and testing stages.

Delivery: Small and regular deliveries of tangible components of the system.

Documentation: Very limited, which was mostly on creation of working software.

Team Structure: Cross-functional teams.

Risk Management: This is by ensuring that feedback sessions are conducted on a regular basis such that if there is a deviation from the desired course, adjustments can be made.

WATERFALL MODELS 
Approach: Staged and therefore each phase is separated.

Flexibility: Low in most cases as the commitments change are hard to make after the completion of a particular phase.

Customer Involvement: Usually confined to what the client has brought at the beginning and the end of the job.

Phases: Specification, design, development, execution, verification, validation, support, improvement.

Delivery: Delivery requires only at the end.

Documentation: Documents compiled at every stage of the process.

Team Structure: Formal, where there is recognition of ranks and obligations among players.

Risk Management: If realised in the early stage, then management becomes challenging because the process is rigid.

Key Differences Between Agile and Waterfall Models

Approach:
Agile:Incremental at a whole-project level and iterative at a team level.
Waterfall: Sequential.

Flexibility:
Agile:High.
Waterfall:Low.

ustomer Involvement:
Agile: Continuous.
Waterfall: Limited.

Delivery:
Agile: Frequent.
Waterfall: Single.

Documentation:
Agile:Minimal.
Waterfall: Extensive.

Team Structure:
Agile:Cross-functional.
Waterfall:Hierarchical.

Scenarios for Preference

Agile:
- Dynamic Requirements.
- Customer Feedback.
- Time-to-Market.
- Innovation and Flexibility.
- Team Collaboration.

Waterfall:
- Well-Defined Requirements.
- Regulated Industries.
- Large Projects.
- Predictable Outcomes.
- Documentation Needs.

Requirements Engineering:
What is requirements engineering? Describe the process and its importance in the software development lifecycle.
ANSWER:
Requirements Engineering

What is Requirements Engineering?
The process of identifying the needs of the software system and defining its functional characteristics is known as requirements engineering. It encompasses the identification of the needs of users and other stakeholders and the communication of the requirement to those into development.

Process:
1. Elicitation: Identify requirements with the help of interviews and workshops with the managers.
2. Analysis:Break down how requirements look like, in terms of importance.
3. Documentation: While documenting requirements it is also important to ensure and state them in a way that would require tools such as use case and requirement specification.
4. Validation:Check and verify requirements with the stakeholders to ensure that the requirements will fulfill their needs and that the ensuing implementation is possible.

Importance in the Software Development Lifecycle:
It should be noted here that while the term ‘manufacturing’ seems to be the preferred one while drafting the bills, ‘industries’ is actually used in the laws that these bills go on to create, and so it is easier to work with this broader, comprehensive term (Cohen 2005).
- Guiding Development: Requirements shape the development process acting as a guide in making sure the right software is developed.
- Minimizing Risks:Setting clear requirements help avoid confusion right from the development phase, eliminating instances of having to redo a project part.
- Customer Satisfaction:As far as the stakeholders are involved, the satisfaction of the customers and successful completion of the projects can be easily attained.
- Efficiency: The clearly defined expectations help in preparing project timelines which in return lessens over expenditures and time mishaps.
- Foundation for Testing:Hedged requirement gives basis for assessment that yields to test whether the software is meeting the requirement or not.


Software Design Principles:
Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
Testing in Software Engineering:
ANSWER:
### Modularity in Software Design

**Concept of Modularity:**
The concept of modularity entails the act of partitioning a software system into micro components or modules which are unique and self-contained within the framework of the overall system with each particular module embracing specific characteristics of the system. It is easier to understand, develop or even maintain a module when they contain elements that are strongly related and the interaction between modules is low.

**Improvement in Maintainability:**
- **Isolation of Changes:** Accepts modifications on one module without interfacing with the rest.
- **Easier Debugging:** Debugging is much easier when the affected module is small, therefore leading to senior identification and fix time.
- **Code Reusability:** Ensures that similar chunks of code are written and maintained within or across projects.

**Enhancement in Scalability:**
- **Flexibility:**Modular design – Implementation allows for addition/removal of specific modules unlike clustered designs that do not allow modification to a specific cluster.
- **Parallel Development:** It facilitates mutual development of modules, hence enhancing efficiency.
- **Resource Allocation:** Enables utilization of resources based on the priority given in the modules thus contributing to efficiency.

### Testing in Software Engineering

**Testing in Software Engineering:**
Testings are the processes that check the software to determine if it meets all the requirements, behaves as intended or is maintainable.

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
ANSWER
**Unit Testing:** Compiles and executes a single module.
- **Integration Testing:It is a testing methodology that aims at or focuses on testing the interactions of various modules.
- **System Testing:** The commerces checks all the features.
- **Acceptance Testing:◦ End customer oriented testing.

**Importance of Testing:**
- **Quality Assurance:** Makes sure software delivered to users meets quality standards.
- **Bug Detection:** Corrects the imperfection and thereby increasing dependability.
- **Risk Mitigation:** Impacts in reducing probability of failure or malfunction.
- **Customer Satisfaction:** Is a way of improving customer satisfaction plus an increase in trust.

Version Control Systems:
What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
ANSWER:
### Version Control Systems

**Some Definition of Version Control Systems**
Version control systems (VCS) primarily control the changes that occur in the source code or documents that are produced.

**Importance in Software Development:**
- **History Tracking:** Calculates and stores the versions of files for further analysis.
- **Collaboration:Centralized repositories: All of the team working material can be kept in one central location and accessed easily by everyone, making the workflow more efficient.
- **Conflict Resolution:** Allows to merge several changes in a document when two or more users are editing the same file.
- **Backup and Recovery:** Serves for backup purposes so in the case of data loss it will be easily retrievable.
- **Branching and Merging:** Permits features branches for local development.

**Popular Version Control Systems:**

1. **Git:**
   - **Features:** Decentralized, loosely integrated, revisions and divergent.
   - **Example:** GitHub.

2. **Subversion (SVN):**
   - **Features:** Organizational units of addresses and associated name-to-ID mapping, Versioned directory trees, Atomic commits.
   - **Example:** Apache Subversion.

3. **Mercurial:**
   - **Features:** Consistency, convenience, highly flexible and fault tolerant branching.
   - **Example:** Bitbucket.

4. **Perforce:**
   - **Features:** Centralized with high performance output for version control.
   - **Example:** Published as per force helix core.

5. **Team Foundation Version Control (TFVC):**### Sisco & Sternberg (1999)<|reserved_special_token_264|>ing (1998)Ding (1998)Wong & Hui (1997)Mintzberg (1998)Huygens & Sanders (1996)Franco & Hamed (1998)Carasco & Amigo (1998)Eroglu et al. (1998) and Donnelly (1998)By followingorganization by activity
   - **Features:** Convenient, tightly integrated into the Microsoft Visual Studio IDE.
   - **Example:** Tieto Azure DevOps Server.

Software Project Management:
Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?

Software Maintenance:
Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Ethical Considerations in Software Engineering:

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?
Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
